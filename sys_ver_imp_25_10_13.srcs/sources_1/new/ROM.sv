`timescale 1ns / 1ps

module ROM(
    input  logic [31:0] addr,
    output logic [31:0] data
);
    logic [31:0] rom[0:2**8 - 1]; //주소 하나에 할당되어 있는 데이터 사이즈 -> 8비트 (1바이트)이다, 즉 4바이트를 한 묶음으로 묶은 것이다.

    initial begin
        /*
        //R-type :  funct7 + Rs2 + Rs1 + funct3 + Rd + Opcode
        rom[0] = 32'b0000000_00001_00010_000_00100_0110011; //add x4, x2, x1
        rom[1] = 32'b0100000_00001_00010_000_00101_0110011; //sub x5, x2, x1
        rom[2] = 32'b0000000_00000_00011_111_00110_0110011; //and x6, x3, x0
        rom[3] = 32'b0000000_00001_00011_110_00111_0110011; //or  x7, x3, x1
        //I-type :  imm + rs1 + funct3 + rd + opcode
        rom[4] = 32'b000000000001_00001_000_01001_0010011; //addi  x9, x1, 1
        rom[5] = 32'b000000000100_00010_111_01010_0010011; //andi  x10, x2, 4
        rom[6] = 32'b000000000011_00001_001_01011_0010011; //slli  x11, x1, 3
        //S-type :
        rom[7] = 32'b0000000_11111_01100_000_00001_0100011; //sb  x12, x31, 1
        rom[8] = 32'b0000000_11111_01101_001_00010_0100011; //sh  x13, x31, 2
        rom[9] = 32'b0000000_11111_01110_010_00011_0100011; //sw  x14, x31, 3
        */
        rom[0] = 32'b0000000_11111_01100_000_00001_0100011; //sb  x12, x31, 1
        rom[1] = 32'b0000000_11111_01101_001_00010_0100011; //sh  x13, x31, 2
        rom[2] = 32'b0000000_11111_01110_010_00011_0100011; //sw  x14, x31, 3

    end

    assign data = rom[addr[31:2]]; //2비트를 무시 -> 4로 나눈 것과 동일하다.

endmodule
